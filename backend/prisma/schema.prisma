generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Hashed password
  name      String
  role      Role     @default(ADMIN)
  isActive  Boolean  @default(true)
  lastLogin DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model VotingToken {
  id           String   @id @default(cuid())
  token        String   @unique
  roundtableId String
  roundtable   Roundtable @relation(fields: [roundtableId], references: [id], onDelete: Cascade)
  participantId String
  participant  Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  expiresAt    DateTime
  usedAt       DateTime?
  createdAt    DateTime @default(now())

  sessions     VotingSession[]

  @@map("voting_tokens")
}

model VotingSession {
  id           String   @id @default(cuid())
  sessionId    String   @unique

  tokenId      String
  token        VotingToken @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  participantId String
  participant  Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  roundtableId String
  roundtable   Roundtable @relation(fields: [roundtableId], references: [id], onDelete: Cascade)

  expiresAt    DateTime
  isUsed       Boolean  @default(false)
  usedAt       DateTime?
  createdAt    DateTime @default(now())

  @@index([sessionId])
  @@index([participantId])
  @@map("voting_sessions")
}

model Client {
  id          String   @id @default(cuid())
  name        String
  email       String
  company     String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  roundtables    Roundtable[]
  clientSettings ClientSettings?

  @@map("clients")
}

model Roundtable {
  id          String            @id @default(cuid())
  name        String
  description String?
  status      RoundtableStatus  @default(SETUP)
  startDate   DateTime?
  endDate     DateTime?
  maxParticipants Int           @default(6)
  formsUrl    String?           // Microsoft Forms URL for this roundtable

  // Dynamic question/feedback limits (per-roundtable customization)
  minQuestionsPerSession            Int @default(0)
  maxQuestionsPerSession            Int @default(10)
  minFeedbackItemsPerParticipant    Int @default(1)
  maxFeedbackItemsPerParticipant    Int @default(5)

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  clientId    String
  client      Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)

  participants    Participant[]
  sessions        Session[]
  topics          Topic[]
  topicVotes      TopicVote[]
  votingTokens    VotingToken[]
  votingSessions  VotingSession[]

  @@map("roundtables")
}

model Participant {
  id          String              @id @default(cuid())
  email       String
  name        String
  company     String?
  languageLevel LanguageLevel     @default(B1)
  status      ParticipantStatus   @default(INVITED)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  roundtableId String
  roundtable   Roundtable         @relation(fields: [roundtableId], references: [id], onDelete: Cascade)

  topicVotes   TopicVote[]
  feedback     Feedback[]
  votingTokens VotingToken[]
  votingSessions VotingSession[]

  @@unique([email, roundtableId])
  @@map("participants")
}

model Topic {
  id          String   @id @default(cuid())
  title       String
  description String
  isSelected  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  roundtableId String
  roundtable   Roundtable @relation(fields: [roundtableId], references: [id], onDelete: Cascade)

  votes       TopicVote[]
  sessions    Session[]
  questionLibrary Question[] @relation("QuestionLibrary")
  questionTemplates QuestionTemplate[]
  aiSuggestions AIQuestionSuggestion[]

  @@map("topics")
}

model TopicVote {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())

  participantId String
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  topicId      String
  topic        Topic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  roundtableId String
  roundtable   Roundtable @relation(fields: [roundtableId], references: [id], onDelete: Cascade)

  @@unique([participantId, topicId])
  @@map("topic_votes")
}

model Trainer {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  expertise String[]
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions  Session[]
  feedback  Feedback[]

  @@map("trainers")
}

model Session {
  id              String              @id @default(cuid())
  sessionNumber   Int                 // 1-10 per ogni roundtable
  scheduledAt     DateTime
  status          SessionStatus       @default(SCHEDULED)
  questionsStatus QuestionsStatus     @default(NOT_REQUESTED)
  feedbacksStatus FeedbacksStatus     @default(NOT_REQUESTED)
  meetingLink     String?
  notes           String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  roundtableId String
  roundtable   Roundtable @relation(fields: [roundtableId], references: [id], onDelete: Cascade)

  topicId      String?
  topic        Topic?     @relation(fields: [topicId], references: [id])

  trainerId    String?
  trainer      Trainer?   @relation(fields: [trainerId], references: [id])

  questions    Question[]
  feedback     Feedback[]
  notifications Notification[]

  @@unique([roundtableId, sessionNumber])
  @@map("sessions")
}

model Question {
  id          String          @id @default(cuid())
  question    String
  status      QuestionStatus  @default(PENDING)
  reviewNotes String?

  // Question library & analytics
  rating      Float?                    // Coordinator rating (1-5 stars)
  usageCount  Int             @default(0)  // Track reuse across sessions
  source      QuestionSource  @default(MANUAL)  // How was this question created
  aiPromptUsed String?                  // Audit trail for AI-generated questions

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  sessionId   String
  session     Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  topicId     String?
  topic       Topic?   @relation("QuestionLibrary", fields: [topicId], references: [id])

  @@index([topicId, rating])
  @@index([source, usageCount])
  @@map("questions")
}

model Feedback {
  id          String         @id @default(cuid())
  content     String
  status      FeedbackStatus @default(PENDING)
  reviewNotes String?
  sentAt      DateTime?

  // Multiple feedback items per participant support
  feedbackType FeedbackType  @default(GENERAL)
  orderIndex   Int           @default(0)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  sessionId     String
  session       Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  participantId String
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  trainerId     String
  trainer       Trainer     @relation(fields: [trainerId], references: [id], onDelete: Cascade)

  @@index([sessionId, participantId, orderIndex])
  @@map("feedback")
}

model Notification {
  id          String            @id @default(cuid())
  type        NotificationType
  recipient   String            // email
  subject     String
  content     String
  status      NotificationStatus @default(PENDING)
  scheduledAt DateTime
  sentAt      DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  sessionId   String?
  session     Session?          @relation(fields: [sessionId], references: [id])

  @@map("notifications")
}

model EmailTemplate {
  id          String               @id @default(cuid())
  name        String
  type        EmailTemplateType
  subject     String
  content     String              @db.Text
  variables   String[]
  isActive    Boolean             @default(true)
  isDefault   Boolean             @default(false)
  category    EmailTemplateCategory
  language    String              @default("en")
  description String?
  tags        String[]
  useCount    Int                 @default(0)
  lastUsed    DateTime?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  createdBy   String

  @@map("email_templates")
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?  // Nullable for anonymous/system actions
  action     String   // 'login', 'create', 'update', 'delete', 'view', 'vote', etc.
  resource   String   // 'user', 'roundtable', 'session', 'vote', etc.
  resourceId String?  // ID of the affected resource
  ipAddress  String?
  userAgent  String?
  result     String   // 'success' | 'failure'
  errorMessage String?
  metadata   Json?    // Additional context
  createdAt  DateTime @default(now())

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([resource, createdAt])
  @@index([result, createdAt])
  @@map("audit_logs")
}

// Question Templates - Reusable question templates by topic
model QuestionTemplate {
  id          String   @id @default(cuid())
  title       String   // Template name (e.g., "Icebreaker Questions")
  question    String   // Template question with placeholders
  description String?  // When to use this template
  tags        String[] // Search tags
  usageCount  Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  topicId     String?
  topic       Topic?   @relation(fields: [topicId], references: [id])

  @@index([topicId, usageCount])
  @@map("question_templates")
}

// AI Question Suggestions - Cache AI-generated suggestions
model AIQuestionSuggestion {
  id          String   @id @default(cuid())
  question    String
  rationale   String?  // Why this question is good
  prompt      String   @db.Text // Prompt used to generate
  sessionId   String?  // Associated session (if specific)
  expiresAt   DateTime // Cache expiry (24h)
  usedByTrainer Boolean @default(false)
  createdAt   DateTime @default(now())

  topicId     String?
  topic       Topic?   @relation(fields: [topicId], references: [id])

  @@index([topicId, expiresAt])
  @@index([sessionId])
  @@map("ai_question_suggestions")
}

// Client Settings - Default question/feedback limits per client
model ClientSettings {
  id          String   @id @default(cuid())

  // Default limits inherited by all roundtables for this client
  defaultMinQuestionsPerSession         Int @default(0)
  defaultMaxQuestionsPerSession         Int @default(10)
  defaultMinFeedbackItemsPerParticipant Int @default(1)
  defaultMaxFeedbackItemsPerParticipant Int @default(5)

  // AI features access
  enableAISuggestions      Boolean @default(true)
  enableQuestionLibrary    Boolean @default(true)
  aiRequestsPerTrainerPerDay Int   @default(5)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  clientId    String   @unique
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("client_settings")
}

// Enums
enum Role {
  ADMIN
  COORDINATOR
  TRAINER
}

enum RoundtableStatus {
  SETUP
  TOPIC_VOTING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ParticipantStatus {
  INVITED
  CONFIRMED
  LEVEL_TEST_REQUIRED
  LEVEL_TEST_FAILED
  ACTIVE
  DROPPED_OUT
}

enum LanguageLevel {
  A1
  A2
  B1
  B2
  C1
  C2
}

// Session overall status
enum SessionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Questions workflow status (separate column)
enum QuestionsStatus {
  NOT_REQUESTED
  REQUESTED_FROM_COORDINATOR    // Automatico 1 settimana prima
  SAVED_BY_TRAINER              // Trainer saved (not submitted yet)
  PENDING_APPROVAL              // Trainer submitted, waiting coordinator
  SENT_TO_PARTICIPANTS          // Manuale: Coordinator sent via email
}

// Feedbacks workflow status (separate column)
enum FeedbacksStatus {
  NOT_REQUESTED
  REQUESTED_FROM_COORDINATOR    // Automatico dopo fine sessione
  SAVED_BY_TRAINER              // Trainer saved (not submitted yet)
  PENDING_APPROVAL              // Trainer submitted, waiting coordinator
  SENT_TO_PARTICIPANTS          // Manuale: Coordinator sent via email
}

// Individual question status (for coordinator review)
enum QuestionStatus {
  PENDING
  APPROVED
  NEEDS_REVISION
  REJECTED
}

// Individual feedback status (for coordinator review)
enum FeedbackStatus {
  PENDING
  APPROVED
  NEEDS_REVISION
  SENT
  REJECTED
}

enum NotificationType {
  TRAINER_REMINDER
  TRAINER_ASSIGNMENT
  QUESTIONS_REQUEST
  FEEDBACK_REQUEST
  PARTICIPANT_EMAIL
  VOTING_INVITE
  SESSION_REMINDER
  SESSION_RESCHEDULE
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

enum EmailTemplateType {
  INVITATION
  REMINDER
  QUESTIONS
  FEEDBACK_REQUEST
  FOLLOW_UP
  CONFIRMATION
  CANCELLATION
}

enum EmailTemplateCategory {
  PARTICIPANT
  TRAINER
  CLIENT
  SYSTEM
}

// Question source tracking
enum QuestionSource {
  MANUAL          // Trainer wrote from scratch
  AI_GENERATED    // Generated by AI
  TEMPLATE        // From question template
  LIBRARY         // Reused from question library
}

// Feedback categorization
enum FeedbackType {
  STRENGTHS       // What the participant did well
  IMPROVEMENTS    // Areas where participant can improve
  RECOMMENDATIONS // Specific actions or resources
  GENERAL         // Unstructured feedback (legacy)
}